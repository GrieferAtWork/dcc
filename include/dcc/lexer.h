/* Copyright (c) 2017 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifndef GUARD_DCC_LEXER_H
#define GUARD_DCC_LEXER_H 1

#include "common.h"
#include "target.h"

#include <stddef.h>

DCC_DECL_BEGIN
struct DCCSym;
DCC_DECL_END

#define DCC_DEBUG_FILE_NOPATH ((struct DCCSym *)(uintptr_t)-1)
#define DCC_DEBUG_FILE_NOFILE ((struct DCCSym *)(uintptr_t)-1)
#define TPP_USERTEXTDATA \
 struct DCCSym *f_dbg_path; /*< [DCC_DEBUG_FILE_NOPATH|0..1] Symbol in '.dbgstr' to the path of this file, or 'DCC_DEBUG_FILE_NOPATH'. */\
 struct DCCSym *f_dbg_file; /*< [DCC_DEBUG_FILE_NOFILE|0..1] Symbol in '.dbgstr' to the filename of this file, or 'DCC_DEBUG_FILE_NOFILE'. */\

#undef TPP
#define TPP   DCC
#include "../../src/tpp/tpp.h"

DCC_DECL_BEGIN

DCCDAT struct TPPFile TPPFile_Cmd;
DCCDAT struct TPPFile TPPFile_Merge;
DCCDAT struct TPPFile TPPFile_Linker;
#if DCC_CONFIG_HAVE_DRT
DCCDAT struct TPPFile TPPFile_DRT;
#endif

#ifdef __INTELLISENSE__
DCCDAT struct TPPKeyword TPPKeyword_Empty;
#else
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4820)
#endif
struct TPPKeyword_Empty_struct {
        struct TPPKeyword *k_next;
 /*ref*/struct TPPFile    *k_macro;
 struct TPPRareKeyword    *k_rare;
 TPP(tok_t)                k_id;
 size_t                    k_size;
 TPP(hash_t)               k_hash;
 char                      k_zero;
};
#ifdef _MSC_VER
#pragma warning(pop)
#endif
DCCDAT struct TPPKeyword_Empty_struct TPPKeyword_Empty_data;
#define TPPKeyword_Empty  (*(struct TPPKeyword *)&TPPKeyword_Empty_data)
#endif

#define DCC_LX_CURRENT (*TPPLexer_Current)
#define DCC_LX_TOK      (TPPLexer_Current->l_token.t_id)
#define DCC_LX_TOKEN    (TPPLexer_Current->l_token)
#define DCC_LX_KWD      (TPPLexer_Current->l_token.t_kwd)
#define DCC_LX_YIELD     TPPLexer_Yield
#define DCC_LX_HAS       TPPLexer_HasExtension
#define DCC_LX_WARN      TPPLexer_Warn
#if 1
#define DCC_LX_OK       (DCC_LX_TOK >= 0)
#else
#define DCC_LX_OK     (!(TPPLexer_Current->l_flags&TPPLEXER_FLAG_ERROR))
#endif

#ifdef DCC_PRIVATE_API
#define CURRENT  DCC_LX_CURRENT
#define TOK      DCC_LX_TOK
#define TOKEN    DCC_LX_TOKEN
#define KWD      DCC_LX_KWD
#define YIELD    DCC_LX_YIELD
#define HAS      DCC_LX_HAS
#define WARN     DCC_LX_WARN
#define OK       DCC_LX_OK
#endif

struct DCCDecl;
struct DCCSym;
struct DCCType;


struct DCCSymExpr {
 DCC(int_t)     e_int; /*< Integral constant, or offset from 'e_sym'. */
 struct DCCSym *e_sym; /*< [0..1] Symbol. NOTE: When generated by 'DCCParse_AsmExpr', this is always a 'DCC_SYMTYPE_LABEL' */
};

struct DCCSymAddr {
 DCC(target_off_t) sa_off; /*< Integral constant offset added to the symbol. */
 struct DCCSym    *sa_sym; /*< [0..1] Symbol added to 'sa_off' during relocations, or NULL if unused. */
};


#define DCC_ATTRSPEC_NONE        0x00000000
#define DCC_ATTRSPEC_NOINLINE    0x00000001 /*< Used for functions: Mark as no-inline. */
#define DCC_ATTRSPEC_NORETURN    0x00000002 /*< Used for functions: Mark as no-return. */
#define DCC_ATTRSPEC_SECTION     0x00000004 /*< An explicit section was defined (When not set, the symbol is used as alias).
                                             *  WARNING: This flag may only be set when 'a_section' is non-NULL. */
#define DCC_ATTRSPEC_WEAK        0x00000008 /*< Used for symbols: Define as weak. */
/*                               0x00000010 */
#define DCC_ATTRSPEC_NOCOLL      0x00000020 /*< Don't exclude a symbol associated with this because it appears unused. */
#define DCC_ATTRSPEC_USED        0x00000040 /*< Don't exclude a symbol associated with this because it appears unused. */
#define DCC_ATTRSPEC_UNUSED      0x00000080 /*< Don't warn about a associated with this not being used. */
#if DCC_TARGET_BIN == DCC_BINARY_PE || \
    defined(GUARD_DCC_LEXER_C) || \
    defined(GUARD_DCC_LEXER_ATTRIBUTES_C_INL)
#define DCC_ATTRSPEC_DLLIMPORT   0x00000100 /*< On PE targets: dllimport. */
#define DCC_ATTRSPEC_DLLEXPORT   0x00000200 /*< On PE targets: dllexport. */
#endif
/*                               0x00000400 */
/*                               0x00000800 */
/*                               0x00001000 */
/*                               0x00002000 */
/*                               0x00004000 */
/*                               0x00008000 */
#define DCC_ATTRSPEC_NAKED       0x00010000 /*< Used for functions: Don't generate a prologue/epilogue. */
#define DCC_ATTRSPEC_CONSTRUCTOR 0x00020000 /*< Used for functions: Run before main(). */
#define DCC_ATTRSPEC_DESTRUCTOR  0x00040000 /*< Used for functions: Run after main(). */
#define DCC_ATTRSPEC_PACKED      0x00080000 /*< When set, tightly pack a structure. */
#define DCC_ATTRSPEC_FIXEDALIGN  0x00100000 /*< When set, 'a_align' contains fixed alignment information. */
#define DCC_ATTRSPEC_TRANSUNION  0x00200000 /*< When set for a union type, it may implicitly be cast of any of its members. */
#define DCC_ATTRSPEC_MSSTRUCT    0x00400000 /*< A structure type is packed using the ms algorithm. */
#define DCC_ATTRSPEC_ARITHMETIC  0x00800000 /*< Allow arithmetic operations with structure types. */
#define DCC_ATTRSPEC_WUNUSED     0x01000000 /*< Used for functions: Warn when return value is unused. */
/*                               0x02000000 */
/*                               0x04000000 */
/*                               0x08000000 */
/*                               0x10000000 */
/*                               0x20000000 */
/*                               0x40000000 */
/*                               0x80000000 */


#define DCC_ATTRFLAG_NONE            0x00000000
/*      DCC_ATTRFLAG_MASK_???        0x00001fff */

#if DCC_TARGET_HASI(I_X86)
#define DCC_ATTRFLAG_MASK_86SEG      0x0000e000 /*< Used for types/variables: Offset instances from %fs. */
#define DCC_ATTRFLAG_SHFT_86SEG      13         /*< Shift for segment address space. */
#define DCC_ATTRFLAG_HAS_86SEG(f)   ((f)&DCC_ATTRFLAG_MASK_86SEG)
#define DCC_ATTRFLAG_GET_86SEG(f)   ((((f)&DCC_ATTRFLAG_MASK_86SEG) >> DCC_ATTRFLAG_SHFT_86SEG)-1)
#define DCC_ATTRFLAG_SET_86SEG(s)   (((s)+1) << DCC_ATTRFLAG_SHFT_86SEG)
#endif /* !I_X86 */

#define DCC_ATTRFLAG_MASK_MODE       0x000f0000 /*< Mask for type mode. */
#define DCC_ATTRFLAG_MODE_NONE       0x00000000
#define DCC_ATTRFLAG_MODE_QI         0x00010000 /*< An integer that is as wide as the smallest addressable unit, usually 8 bits. */
#define DCC_ATTRFLAG_MODE_HI         0x00020000 /*< An integer, twice as wide as a QI mode integer, usually 16 bits. */
#define DCC_ATTRFLAG_MODE_SI         0x00030000 /*< An integer, four times as wide as a QI mode integer, usually 32 bits. */
#define DCC_ATTRFLAG_MODE_DI         0x00040000 /*< An integer, eight times as wide as a QI mode integer, usually 64 bits. */
#define DCC_ATTRFLAG_MODE_SF         0x00050000 /*< A floating point value, as wide as a SI mode integer, usually 32 bits. */
#define DCC_ATTRFLAG_MODE_DF         0x00060000 /*< A floating point value, as wide as a DI mode integer, usually 64 bits. */
/*      DCC_ATTRFLAG_MODE_???        0x00070000 */
/*      DCC_ATTRFLAG_MODE_???        ...        */
/*      DCC_ATTRFLAG_MODE_???        0x000f0000 */

#define DCC_ATTRFLAG_MASK_REACHABLE  0x00f00000 /*< Mask for behavior when reached. */
#define DCC_ATTRFLAG_REACH_DEPR      0x00000000 /*< [if(a_depr != NULL)] Emit a deprecation warning when this function is reached. */
#define DCC_ATTRFLAG_REACH_WARN      0x00100000 /*< [if(a_depr != NULL)] Emit a warning when this function is reached. */
#define DCC_ATTRFLAG_REACH_ERROR     0x00200000 /*< [if(a_depr != NULL)] Emit an error when this function is reached. */
/*      DCC_ATTRFLAG_REACH_???       0x00300000 */
/*      DCC_ATTRFLAG_REACH_???       ...        */
/*      DCC_ATTRFLAG_REACH_???       0x00f00000 */

#define DCC_ATTRFLAG_MASK_CALLCONV   0x0f000000 /*< Mask for calling-convention flags. */
#define DCC_ATTRFLAG_CC_CDECL        0x00000000 /*< Use cdecl calling conventions. */
#define DCC_ATTRFLAG_CC_STDCALL      0x01000000 /*< Use stdcall calling conventions. */
#define DCC_ATTRFLAG_CC_THISCALL     0x02000000 /*< Use thiscall calling conventions. */
#define DCC_ATTRFLAG_CC_FASTCALL     0x03000000 /*< Use fastcall calling conventions. */
/*      DCC_ATTRFLAG_CC_???          0x04000000 */
/*      DCC_ATTRFLAG_CC_???          ...        */
/*      DCC_ATTRFLAG_CC_???          0x0f000000 */

#define DCC_ATTRFLAG_MASK_VISIBILITY 0xf0000000 /*< Mask for ELF-visibility flags. */
#define DCC_ATTRFLAG_VIS_NONE        0x00000000 /*< No special visibility (use command-line option '-fvisibility=...'). */
#define DCC_ATTRFLAG_VIS_DEFAULT     0x10000000 /*< Default/automatic visibility. */
#define DCC_ATTRFLAG_VIS_HIDDEN      0x20000000 /*< Hidden visibility. */
#define DCC_ATTRFLAG_VIS_PROTECTED   0x30000000 /*< Protected visibility. */
#define DCC_ATTRFLAG_VIS_INTERNAL    0x40000000 /*< Internal visibility. */

struct DCCAttrDecl {
 uint32_t                  a_specs;    /*< Attribute specs (Set of 'DCC_ATTRSPEC_*') */
 uint32_t                  a_flags;    /*< Attribute flags (Set of 'DCC_ATTRFLAG_*') */
 uint8_t                   a_regparm;  /*< Used for __attribute__((regparm(...))) */
 uint8_t                   a_padding1; /*< Padding/unused... */
 uint16_t                  a_padding2; /*< Padding/unused... */
union{
 /*ref*/struct DCCSection *a_section;  /*< [0..1][DCC_ATTRSPEC_SECTION] Used for __attribute__((section(...))) */
 /*ref*/struct DCCSym     *a_alias;    /*< [0..1][!DCC_ATTRSPEC_SECTION] Used for __attribute__((alias(...))) */
};
 /*ref*/struct TPPString  *a_reach;    /*< [0..1] Used for __attribute__((deprecated(...))) (User-defined warning text when declaration is reached) */
union{
 DCC(target_siz_t)         a_align;    /*< Used by 'DCC_ATTRSPEC_FIXEDALIGN' */
 DCC(target_off_t)         a_offset;   /*< Used with 'a_alias' for alias-offsets. */
};
 int                       a_c_prio;   /*< Constructor priority, or '0' when using default. */
 int                       a_d_prio;   /*< Destructor priority, or '0' when using default. */
};
#define DCCATTRDECL_INIT  {0,0,0,0,0,{NULL},NULL,{0},0,0}

#define DCCATTRDECL_HASSECTION_OR_IMPORT(self) ((self)->a_section && ((self)->a_specs&DCC_ATTRSPEC_SECTION))
#define DCCATTRDECL_HASALIAS(self)             ((self)->a_alias && !((self)->a_specs&DCC_ATTRSPEC_SECTION))
#define DCCATTRDECL_HASSECTION(self)           (DCCATTRDECL_HASSECTION_OR_IMPORT(self) && !DCCSection_ISIMPORT((self)->a_section))
#define DCCATTRDECL_HASIMPORT(self)            (DCCATTRDECL_HASSECTION_OR_IMPORT(self) && DCCSection_ISIMPORT((self)->a_section))
#define DCCATTRDECL_GETSECTION_OR_IMPORT(self) (((self)->a_specs&DCC_ATTRSPEC_SECTION) ? (self)->a_section : NULL)

#define DCCAttrDecl_Init(self) memset(self,0,sizeof(struct DCCAttrDecl))
DCCFUN void DCCAttrDecl_Quit(struct DCCAttrDecl *__restrict self);
DCCFUN void DCCAttrDecl_Merge(struct DCCAttrDecl *__restrict self,
                              struct DCCAttrDecl const *__restrict rhs);
DCCFUN void DCCAttrDecl_InitCopy(struct DCCAttrDecl *__restrict self,
                                 struct DCCAttrDecl const *__restrict rhs);

/* Returns true if the given attribute
 * declaration is empty (aka. zero-initialized). */
DCCFUN int DCCAttrDecl_IsEmpty(struct DCCAttrDecl const *__restrict self);

/* The pragma parser hook for tpp. */
DCCFUN int DCCParse_Pragma(void);
DCCFUN int DCCParse_GCCPragma(void);
DCCFUN int DCCParse_InsComment(struct TPPString *__restrict comment);

/* For the sake of optimization, the parser calls using fastcall. */
#define DCC_PARSE_CALL  DCC_ATTRIBUTE_FASTCALL

/* Parse __attribute__, __declspec and [[...]] attribute blocks. */
DCCFUN void DCC_PARSE_CALL DCCParse_Attr(struct DCCAttrDecl *__restrict self);


/* Parse a C type and store its declaration in '*result'
 * In addition, the given 'attr' may be modified (but
 * not initialized) when attributes are encountered.
 * @return: 0:
 * @return: NULL: There is no type declaration at the current
 *                source location ('attr' may have still been modified)
 *                NOTE: This value is also returned when an error
 *                      occurred and a lexer error was set.
 *                NOTE: Even in this state, 'self' is initialized to
 *                      'int', meaning you can always use it as type.
 * @return: !0:   Successfully parsed a new type declaration.
 * @return: *:    *ditto* (Returns the name of a keyword hidden inside, or 'TPPKeyword_Empty' is none was)
 * HINT: 'DCCParse_CTypeSuffix' never returns NULL. */
DCCFUN struct TPPKeyword *DCC_PARSE_CALL DCCParse_CType(struct DCCType *__restrict self, struct DCCAttrDecl *__restrict attr);
DCCFUN int                DCC_PARSE_CALL DCCParse_CTypePrefix(struct DCCType *__restrict self, struct DCCAttrDecl *__restrict attr);
DCCFUN struct TPPKeyword *DCC_PARSE_CALL DCCParse_CTypeSuffix(struct DCCType *__restrict self, struct DCCAttrDecl *__restrict attr);

/* Guess the meaning of a given CType.
 * >> This function is used to try and interpret unknown
 *    type keywords when encountered and knows of various
 *    types used in system headers, such as more common
 *    ones like 'size_t', but even more specific, and even
 *    target-specific types, such as 'DWORD' or '__u8'
 * NOTE: This function will not emit a warning for guess types. - The caller must do this!
 * @return: 0: Failed to guess the intended type from 'name..+=size'
 * @return: 1: Successfully guessed the intended type.
 * HINT: In the event that FALSE(0) is returned, 'self' is still initialized to 'int'. */
DCCFUN int DCC_PARSE_CALL
DCCParse_CTypeGuess(struct DCCType *__restrict self,
                    struct DCCAttrDecl *__restrict attr,
                    char const *__restrict name, size_t size);

/* Same as 'DCCParse_CType', but unknown keywords
 * are interpreted as 'int', as well as warned about. */
DCCFUN struct TPPKeyword *DCC_PARSE_CALL
DCCParse_CTypeUnknown(struct DCCType *__restrict self,
                      struct DCCAttrDecl *__restrict attr);

/* Force-parse a full c-type, emitting a warning and instead parsing an
 * single expression who's type will be taken when no type could be found.
 * Other than that, this function behaves exactly the same as 'DCCParse_CType',
 * with the addition that instead of returning NULL, '&TPPKeyword_Empty' is returned. */
DCCFUN struct TPPKeyword *DCC_PARSE_CALL
DCCParse_CTypeOnly(struct DCCType *__restrict self, struct DCCAttrDecl *__restrict attr);

/* Parse struct members, adding all to the 'd_tdecl.td_fieldv'
 * vector of the given structure type symbol 'struct_decl'.
 * NOTE: The calling is responsible to only pass a 'DCC_DECLKIND_STRUCT'
 *       symbol with its field vector initialized to NULL.
 * NOTE: Once done, the caller must still calculate
 *       member offsets and alignment, thus allowing
 *       the user to write additional attributes _after_
 *       the struct, that will still be parsed as part of it. */
DCCFUN void DCC_PARSE_CALL DCCParse_Struct(struct DCCDecl *__restrict struct_decl);

/* Parse enum contents, enumerating incrementing
 * constant expressions that declare global symbols.
 * Parsing stops once no more symbol names are encountered. */
DCCFUN void DCC_PARSE_CALL DCCParse_Enum(void);

/* Parse a c expression.
 * NOTE: The expression is then put on the VStack. */
DCCFUN void DCC_PARSE_CALL DCCParse_Expr(void);        /* Parse comma-separated expressions, only leaving the last in 'vbottom'. */
DCCFUN void DCC_PARSE_CALL DCCParse_Expr1(void);       /* Parse a single expression. */
DCCFUN size_t DCC_PARSE_CALL DCCParse_Exprn(void);     /* Parse comma-separated expressions, leaving all on-stack and returning the amount parsed. */
DCCFUN void DCC_PARSE_CALL DCCParse_ExprDiscard(void); /* Parse a comma-separated list of expression, but immediately discard it (used for implementing optional, variadic arguments in builtin functions). */
DCCFUN int DCC_PARSE_CALL DCCParse_IsExpr(void);       /* Only looking at the current token, try to guess if it may indicate the start of an expression (returns 0/1 indicative of that guess). */

/* Similar to 'DCCParse_Expr', but require a constant expression
 * to be parsed, as well as not generating any code along the way.
 * Once done, this function returns the constant expression's value. */
DCCFUN DCC(int_t) DCC_PARSE_CALL DCCParse_CExpr(int one);
DCCFUN void DCC_PARSE_CALL DCCParse_CExpr2(int one, struct DCCSymExpr *__restrict result);

struct DCCMemLoc;

/* Parse an initializer for the given type 'type'.
 * NOTE: The value parsed will be located in vbottom upon return.
 * @param: flags:  A set of 'DCCPARSE_INITFLAG_*'
 * @param: target: When non-NULL, specify a custom target for the initializer.
 *                 When NULL, the target is automatically determined,
 *                 usually as a value on the stack, a register, or a constant. */
DCCFUN void DCC_PARSE_CALL
DCCParse_Init(struct DCCType const *__restrict type,
              struct DCCAttrDecl const *attr,
              struct DCCMemLoc const *target,
              uint32_t flags);
#define DCCPARSE_INITFLAG_NONE    0x00000000
#define DCCPARSE_INITFLAG_INITIAL 0x00000001 /*< Set for initial initializations. */
#define DCCPARSE_INITFLAG_INBRACE 0x00000002 /*< Set during recursive initialization to allow for automatic skipping of braces. */

/* Parse and assign an initializer to 'vbottom' */
DCCFUN void DCC_PARSE_CALL DCCParse_VInit(uint32_t flags);



/* Parse a variable declaration. The declaration is then pushed on the v-stack.
 * @return: 0: Failed to parse a type.
 * @return: 1: Successfully parsed a declaration.
 * @return: 2: Successfully parsed a declaration that doesn't require a terminating ';'. */
DCCFUN int DCC_PARSE_CALL DCCParse_Decl(void);

/* Parse a declaration of expression.
 * @return: 0: Parsed an expression.
 * @return: 1: Parsed a declaration.
 * @return: 2: Parsed a declaration that doesn't require a terminating ';'. */
DCCFUN int DCC_PARSE_CALL DCCParse_DeclOrExpr(void);

/* Parse a global statement (basically the same as parsing
 * a declaration, but substitutes missing types for it)
 * NOTE: Also parses empty statements and requires declarations to end with a ';'
 * WARNING: The caller must still vpop(1) the parsed value. */
DCCFUN void DCC_PARSE_CALL DCCParse_Global(void);

/* Similar to 'DCCParse_Global', but safely parses _everything_ */
DCCFUN void DCC_PARSE_CALL DCCParse_AllGlobal(void);


/* Returns the canonical name of a library described by 'name...+=size',
 * emitting warnings about invalid characters or constructs as well as
 * removing any whitespace or unifying path slashes.
 * NOTE: This function respects the 'EXT_CANONICAL_LIB_NAMES' extension
 *       and will return the given name unmodified when it is disabled. */
DCCFUN struct TPPKeyword *DCCParse_GetLibname(char const *__restrict name, size_t size);


#define DCC_PFLAG_NONE     0x00000000
#define DCC_PFLAG_USED     0x00000001 /*< The v-stack result of the statement is used, meaning it must be
                                       *  preserved (This flag is set when parsing statement-expressions). */
#define DCC_PFLAG_WARNDECL 0x00000002 /*< Warn about mixed statement/declarations. */

typedef int DCC(pflag_t); /*< A set of 'DCC_PFLAG_*' */

/* Parse a statement, pushing one value on the vstack.
 * @return: 0: A statement or expression was parsed.
 * @return: 1: A declaration was parsed (as well as its ';').
 * @return: 2: A declaration that didn't require a ';' was parsed. */
DCCFUN int DCC_PARSE_CALL DCCParse_Stmt(DCC(pflag_t) f);

/* Parse a static assertion:
 * >> _Static_assert(sizeof(int) == 4,"Oh no!");
 *    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 * The caller is responsible to ensure that the
 * current token is '_Static_assert' upon entry. */
DCCFUN void DCC_PARSE_CALL DCCParse_StaticAssert(void);

#define TPP_ISSTRING(t) \
  ((t) == DCC(TOK_STRING) || \
  (DCC_LX_HAS(DCC(EXT_FUNCTION_STRING_LITERALS)) &&\
  ((t) == DCC(KWD___FUNCTION__) || \
   (t) == DCC(KWD___PRETTY_FUNCTION__))))
DCCFUN /*ref*/struct TPPString *DCCParse_String(void);



#if 1 /* Allow __pack to skip parenthesis in most places. */
#define DCCParse_ParPairHas()   _has_paren
#define DCCParse_ParPairBegin() \
do{ int _has_paren = DCC_LX_TOK == '('; \
    if (_has_paren) DCC_LX_YIELD();\
    else if (DCC_LX_TOK == DCC(KWD___pack)) \
    { DCC_LX_YIELD(); _has_paren = (DCC_LX_TOK == '('); if (_has_paren) DCC_LX_YIELD(); }\
    else _has_paren = 1,DCC_LX_WARN(DCC(W_EXPECTED_LPAREN))
#define DCCParse_ParPairEnd() \
    if (_has_paren) {\
     if (DCC_LX_TOK == ')') DCC_LX_YIELD();\
     else DCC_LX_WARN(DCC(W_EXPECTED_RPAREN));\
    }\
}while(DCC_MACRO_FALSE)
#else
#define DCCParse_ParPairHas()   1
#define DCCParse_ParPairBegin() \
do{ if (DCC_LX_TOK == '(') DCC_LX_YIELD();\
    else DCC_LX_WARN(DCC(W_EXPECTED_LPAREN))
#define DCCParse_ParPairEnd() \
    if (DCC_LX_TOK == ')') DCC_LX_YIELD();\
    else DCC_LX_WARN(DCC(W_EXPECTED_RPAREN));\
}while(DCC_MACRO_FALSE)
#endif

#define DCCParse_ParPairOptHas()   _opt_has_paren
#define DCCParse_ParPairOptBegin() \
do{ int _opt_has_paren = DCC_LX_TOK == '('; \
    if (_opt_has_paren) DCC_LX_YIELD();\
    else if (DCC_LX_TOK == DCC(KWD___pack)) DCC_LX_YIELD();\
    else do; while(DCC_MACRO_FALSE)
#define DCCParse_ParPairOptEnd() \
    if (_opt_has_paren) {\
     if (DCC_LX_TOK == ')') DCC_LX_YIELD();\
     else DCC_LX_WARN(DCC(W_EXPECTED_RPAREN));\
    }\
}while(DCC_MACRO_FALSE)




DCC_DECL_END

#endif /* !GUARD_DCC_LEXER_H */
